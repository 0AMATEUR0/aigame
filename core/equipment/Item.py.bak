"""
ç‰©å“ç³»ç»Ÿæ¨¡å—
åŒ…å«åŸºç¡€ç‰©å“ç±»ã€è£…å¤‡ç±»ã€æ¶ˆè€—å“ç±»ç­‰åŸºæœ¬ç‰©å“ç±»å‹çš„å®šä¹‰ï¼Œ
ä»¥åŠç‰©å“å·¥å‚ã€ç‰©å“åŠ è½½ä¿å­˜ç­‰åŠŸèƒ½
"""

from utils.dice import roll_detail
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import json
import copy

# ===== æšä¸¾å®šä¹‰ =====
class ItemRarity(Enum):
    """ç‰©å“ç¨€æœ‰åº¦æšä¸¾"""
    COMMON = "æ™®é€š"
    UNCOMMON = "ä¼˜ç§€"
    RARE = "ç¨€æœ‰"
    EPIC = "å²è¯—"
    LEGENDARY = "ä¼ è¯´"

class ItemType(Enum):
    """ç‰©å“ç±»å‹æšä¸¾"""
    WEAPON = "æ­¦å™¨"
    ARMOR = "æŠ¤ç”²"
    CONSUMABLE = "æ¶ˆè€—å“"
    MATERIAL = "ææ–™"
    QUEST = "ä»»åŠ¡ç‰©å“"
    TREASURE = "å®è—"

class EquipmentSlot(Enum):
    """è£…å¤‡æ§½ä½æšä¸¾"""
    WEAPON = "weapon"
    ARMOR = "armor"
    SHIELD = "shield"
    HELMET = "helmet"
    GLOVES = "gloves"
    BOOTS = "boots"
    RING = "ring"
    AMULET = "amulet"

# ===== ç‰©å“åŸºç±» =====
class BaseItem:
    def __init__(self, name: str, description: str = "", value: int = 0,
                 rarity: ItemRarity = ItemRarity.COMMON,
                 item_type: ItemType = ItemType.MATERIAL,
                 weight: float = 0.0,
                 stackable: bool = False,
                 max_stack: int = 1,
                 tags: List[str] = None):
        self.name = name
        self.description = description
        self.value = value
        self.rarity = rarity
        self.item_type = item_type
        self.weight = weight
        self.stackable = stackable
        self.max_stack = max_stack
        self.tags = tags or []
        self.id = f"{name}_{rarity.value}_{item_type.value}"

    def __repr__(self):
        return f"<{self.rarity.value}{self.item_type.value}: {self.name}>"

    def get_display_name(self) -> str:
        rarity_colors = {
            ItemRarity.COMMON: "",
            ItemRarity.UNCOMMON: "ğŸŸ¢",
            ItemRarity.RARE: "ğŸ”µ",
            ItemRarity.EPIC: "ğŸŸ£",
            ItemRarity.LEGENDARY: "ğŸŸ¡"
        }
        return f"{rarity_colors.get(self.rarity, '')}{self.name}"

    def get_full_description(self) -> str:
        desc = f"{self.get_display_name()}\nç±»å‹: {self.item_type.value}\nç¨€æœ‰åº¦: {self.rarity.value}\nä»·å€¼: {self.value} é‡‘å¸"
        if self.weight > 0:
            desc += f"\né‡é‡: {self.weight} ç£…"
        if self.description:
            desc += f"\næè¿°: {self.description}"
        if self.tags:
            desc += f"\næ ‡ç­¾: {', '.join(self.tags)}"
        return desc

    def can_use(self, character) -> bool:
        return True

    def use(self, character) -> bool:
        return False

    def to_dict(self) -> Dict:
        return {
            "name": self.name,
            "description": self.description,
            "value": self.value,
            "rarity": self.rarity.value,
            "item_type": self.item_type.value,
            "weight": self.weight,
            "stackable": self.stackable,
            "max_stack": self.max_stack,
            "tags": self.tags
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'BaseItem':
        return cls(
            name=data["name"],
            description=data.get("description", ""),
            value=data.get("value", 0),
            rarity=ItemRarity(data.get("rarity", "æ™®é€š")),
            item_type=ItemType(data.get("item_type", "ææ–™")),
            weight=data.get("weight", 0.0),
            stackable=data.get("stackable", False),
            max_stack=data.get("max_stack", 1),
            tags=data.get("tags", [])
        )

# ===== è£…å¤‡ç±» =====
class Equipment(BaseItem):
    def __init__(self, name: str, slot: EquipmentSlot, level_requirement: int = 1,
                 effects: Dict[str, Any] = None, **kwargs):
        super().__init__(name, item_type=ItemType.WEAPON if slot == EquipmentSlot.WEAPON else ItemType.ARMOR, **kwargs)
        self.slot = slot
        self.level_requirement = level_requirement
        self.effects = effects or {}
        self.durability = 100
        self.max_durability = 100

    def can_equip(self, character) -> (bool, str):
        if character.level < self.level_requirement:
            return False, f"éœ€è¦ç­‰çº§ {self.level_requirement}"
        return True, "å¯ä»¥è£…å¤‡"

    def apply_effects(self, character):
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value + effect_value)

    def remove_effects(self, character):
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value - effect_value)

    def take_damage(self, amount: int):
        self.durability = max(0, self.durability - amount)
        if self.durability <= 0:
            print(f"âš ï¸ {self.name} å·²ç»æŸåï¼")

    def repair(self, amount: int = 100):
        self.durability = min(self.max_durability, self.durability + amount)
        print(f"ğŸ”§ {self.name} è¢«ä¿®å¤äº† {amount} ç‚¹è€ä¹…åº¦")

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nè£…å¤‡æ§½: {self.slot.value}"
        desc += f"\nç­‰çº§è¦æ±‚: {self.level_requirement}"
        desc += f"\nè€ä¹…åº¦: {self.durability}/{self.max_durability}"
        if self.effects:
            desc += f"\næ•ˆæœ: {', '.join([f'{k}+{v}' for k, v in self.effects.items()])}"
        return desc

class Weapon(Equipment):
    def __init__(self, name: str, damage_dice: str, damage_type: str = "ç‰©ç†",
                 weapon_type: str = "è¿‘æˆ˜", attack_bonus: int = 0, critical_range: int = 20,
                 critical_multiplier: int = 2, **kwargs):
        super().__init__(name, slot=EquipmentSlot.WEAPON, **kwargs)
        self.damage_dice = damage_dice
        self.damage_type = damage_type
        self.weapon_type = weapon_type
        self.attack_bonus = attack_bonus
        self.critical_range = critical_range
        self.critical_multiplier = critical_multiplier

    def get_damage(self, strength: int, crit: bool = False) -> int:
        dmg_res = roll_detail(self.damage_dice, crit=crit)
        damage = dmg_res["total"] + strength
        print(f"{self.name} ä¼¤å®³: {dmg_res['rolls']} + åŠ›é‡({strength}) â†’ {damage}")
        return damage

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä¼¤å®³: {self.damage_dice} + åŠ›é‡"
        desc += f"\nä¼¤å®³ç±»å‹: {self.damage_type}"
        desc += f"\næ­¦å™¨ç±»å‹: {self.weapon_type}"
        desc += f"\næ”»å‡»åŠ å€¼: {self.attack_bonus:+d}"
        desc += f"\næš´å‡»èŒƒå›´: {self.critical_range}"
        desc += f"\næš´å‡»å€æ•°: x{self.critical_multiplier}"
        return desc

class Armor(Equipment):
    def __init__(self, name: str, armor_class: int, armor_type: str = "è½»ç”²",
                 max_dex_bonus: Optional[int] = None, **kwargs):
        super().__init__(name, slot=EquipmentSlot.ARMOR, **kwargs)
        self.armor_class = armor_class
        self.armor_type = armor_type
        self.max_dex_bonus = max_dex_bonus

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næŠ¤ç”²ç­‰çº§: {self.armor_class}"
        desc += f"\næŠ¤ç”²ç±»å‹: {self.armor_type}"
        if self.max_dex_bonus is not None:
            desc += f"\næœ€å¤§æ•æ·åŠ å€¼: {self.max_dex_bonus}"
        return desc

class Consumable(BaseItem):
    def __init__(self, name: str, use_effect: Callable = None, charges: int = 1, **kwargs):
        super().__init__(name, item_type=ItemType.CONSUMABLE, stackable=True, **kwargs)
        self.use_effect = use_effect
        self.charges = charges

    def use(self, character) -> bool:
        if self.use_effect:
            return self.use_effect(character, self)
        return False

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä½¿ç”¨æ¬¡æ•°: {self.charges}"
        return desc

class HPPotion(Consumable):
    def __init__(self, name: str = "ç”Ÿå‘½è¯æ°´", heal_amount: int = 10, **kwargs):
        def heal_effect(character, item):
            character.heal(heal_amount)
            print(f"ğŸ’š {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {heal_amount} ç‚¹ç”Ÿå‘½ï¼ï¼ˆ{character.hp}/{character.max_hp} HPï¼‰")
            return True
        super().__init__(name, use_effect=heal_effect, **kwargs)
        self.heal_amount = heal_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.heal_amount} ç‚¹ç”Ÿå‘½å€¼"
        return desc

class MPPotion(Consumable):
    def __init__(self, name: str = "é­”æ³•è¯æ°´", mana_amount: int = 10, **kwargs):
        def mana_effect(character, item):
            character.mp = min(character.max_mp, character.mp + mana_amount)
            print(f"ğŸ”® {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {mana_amount} ç‚¹é­”æ³•ï¼ï¼ˆ{character.mp}/{character.max_mp} MPï¼‰")
            return True
        super().__init__(name, use_effect=mana_effect, **kwargs)
        self.mana_amount = mana_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.mana_amount} ç‚¹é­”æ³•å€¼"
        return desc

# ===== ç‰©å“å·¥å‚ =====
class ItemFactory:
    @staticmethod
    def create_weapon(name: str, damage_dice: str, **kwargs) -> Weapon:
        return Weapon(name, damage_dice, **kwargs)
    @staticmethod
    def create_armor(name: str, armor_class: int, **kwargs) -> Armor:
        return Armor(name, armor_class, **kwargs)
    @staticmethod
    def create_hp_potion(name: str = "ç”Ÿå‘½è¯æ°´", heal_amount: int = 10, **kwargs) -> HPPotion:
        return HPPotion(name, heal_amount, **kwargs)
    @staticmethod
    def create_mp_potion(name: str = "é­”æ³•è¯æ°´", mana_amount: int = 10, **kwargs) -> MPPotion:
        return MPPotion(name, mana_amount, **kwargs)
    @staticmethod
    def create_from_template(template: Dict) -> BaseItem:
        t = template.copy()
        if "rarity" in t and not isinstance(t["rarity"], ItemRarity):
            try:
                t["rarity"] = ItemRarity(t["rarity"])
            except Exception:
                t["rarity"] = ItemRarity.COMMON
        item_type_str = t.get("type") or t.get("item_type")
        if item_type_str and not isinstance(item_type_str, ItemType):
            try:
                t["item_type"] = ItemType(item_type_str)
            except Exception:
                t["item_type"] = ItemType.MATERIAL
        type_str = t.get("type")
        if type_str == "weapon":
            return Weapon(
                name=t["name"],
                damage_dice=t["damage_dice"],
                damage_type=t.get("damage_type", "ç‰©ç†"),
                weapon_type=t.get("weapon_type", "è¿‘æˆ˜"),
                attack_bonus=t.get("attack_bonus", 0),
                critical_range=t.get("critical_range", 20),
                critical_multiplier=t.get("critical_multiplier", 2),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "damage_dice", "damage_type", "weapon_type", "attack_bonus", "critical_range", "critical_multiplier"]}
            )
        elif type_str == "armor":
            return Armor(
                name=t["name"],
                armor_class=t["armor_class"],
                armor_type=t.get("armor_type", "è½»ç”²"),
                max_dex_bonus=t.get("max_dex_bonus"),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "armor_class", "armor_type", "max_dex_bonus"]}
            )
        elif type_str == "hp_potion":
            return HPPotion(
                name=t["name"],
                heal_amount=t.get("heal_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "heal_amount"]}
            )
        elif type_str == "mp_potion":
            return MPPotion(
                name=t["name"],
                mana_amount=t.get("mana_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "mana_amount"]}
            )
        t.pop("type", None)
        return BaseItem(**t)

# ===== ç‰©å“åŠ è½½ä¸å…¨å±€æ³¨å†Œ =====
def load_items_from_json(file_path: str) -> Dict[str, BaseItem]:
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        items = {}
        for item_name, template in data.items():
            items[item_name] = ItemFactory.create_from_template(template)
        return items
    except FileNotFoundError:
        print(f"ç‰©å“æ–‡ä»¶æœªæ‰¾åˆ°: {file_path}")
        return {}
    except json.JSONDecodeError as e:
        print(f"ç‰©å“æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
        return {}

def save_items_to_json(items: Dict[str, BaseItem], file_path: str):
    data = {}
    for item_name, item in items.items():
        data[item_name] = item.to_dict()
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

ITEM_REGISTRY = {}
ITEM_JSON_PATH = "core/equipment/itemjson.json"

def load_global_items(json_path=ITEM_JSON_PATH):
    global ITEM_REGISTRY
    ITEM_REGISTRY = load_items_from_json(json_path)
    if not ITEM_REGISTRY:
        print(f"æœªèƒ½åŠ è½½ä»»ä½•ç‰©å“ï¼Œè¯·æ£€æŸ¥ {json_path}")
    else:
        print(f"å·²åŠ è½½ {len(ITEM_REGISTRY)} ä¸ªç‰©å“")

def get_item_by_name(item_name: str):
    if not ITEM_REGISTRY:
        load_global_items()
    item = ITEM_REGISTRY.get(item_name)
    if item:
        import copy
        return copy.deepcopy(item)
    else:
        raise ValueError(f"æœªæ‰¾åˆ°ç‰©å“: {item_name}")
from utils.dice import roll_detail
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import json

class ItemRarity(Enum):
    COMMON = "æ™®é€š"
    UNCOMMON = "ä¼˜ç§€"
    RARE = "ç¨€æœ‰"
    EPIC = "å²è¯—"
    LEGENDARY = "ä¼ è¯´"

class ItemType(Enum):
    WEAPON = "æ­¦å™¨"
    ARMOR = "æŠ¤ç”²"
    CONSUMABLE = "æ¶ˆè€—å“"
    MATERIAL = "ææ–™"
    QUEST = "ä»»åŠ¡ç‰©å“"
    TREASURE = "å®è—"

class EquipmentSlot(Enum):
    WEAPON = "weapon"
    ARMOR = "armor"
    SHIELD = "shield"
    HELMET = "helmet"
    GLOVES = "gloves"
    BOOTS = "boots"
    RING = "ring"
    AMULET = "amulet"

class BaseItem:
    def __init__(self, name: str, description: str = "", value: int = 0,
                 rarity: ItemRarity = ItemRarity.COMMON,
                 item_type: ItemType = ItemType.MATERIAL,
                 weight: float = 0.0,
                 stackable: bool = False,
                 max_stack: int = 1,
                 tags: List[str] = None):
        self.name = name
        self.description = description
        self.value = value
        self.rarity = rarity
        self.item_type = item_type
        self.weight = weight
        self.stackable = stackable
        self.max_stack = max_stack
        self.tags = tags or []
        self.id = f"{name}_{rarity.value}_{item_type.value}"

    def __repr__(self):
        return f"<{self.rarity.value}{self.item_type.value}: {self.name}>"

    def get_display_name(self) -> str:
        rarity_colors = {
            ItemRarity.COMMON: "",
            ItemRarity.UNCOMMON: "ğŸŸ¢",
            ItemRarity.RARE: "ğŸ”µ",
            ItemRarity.EPIC: "ğŸŸ£",
            ItemRarity.LEGENDARY: "ğŸŸ¡"
        }
        return f"{rarity_colors.get(self.rarity, '')}{self.name}"

    def get_full_description(self) -> str:
        desc = f"{self.get_display_name()}\n"
        desc += f"ç±»å‹: {self.item_type.value}\n"
        desc += f"ç¨€æœ‰åº¦: {self.rarity.value}\n"
        desc += f"ä»·å€¼: {self.value} é‡‘å¸\n"
        if self.weight > 0:
            desc += f"é‡é‡: {self.weight} ç£…\n"
        if self.description:
            desc += f"æè¿°: {self.description}\n"
        if self.tags:
            desc += f"æ ‡ç­¾: {', '.join(self.tags)}\n"
        return desc.strip()

    def can_use(self, character) -> bool:
        return True

    def use(self, character) -> bool:
        return False

    def to_dict(self) -> Dict:
        return {
            "name": self.name,
            "description": self.description,
            "value": self.value,
            "rarity": self.rarity.value,
            "item_type": self.item_type.value,
            "weight": self.weight,
            "stackable": self.stackable,
            "max_stack": self.max_stack,
            "tags": self.tags
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'BaseItem':
        return cls(
            name=data["name"],
            description=data.get("description", ""),
            value=data.get("value", 0),
            rarity=ItemRarity(data.get("rarity", "æ™®é€š")),
            item_type=ItemType(data.get("item_type", "ææ–™")),
            weight=data.get("weight", 0.0),
            stackable=data.get("stackable", False),
            max_stack=data.get("max_stack", 1),
            tags=data.get("tags", [])
        )

class Equipment(BaseItem):
    def __init__(self, name: str, slot: EquipmentSlot, level_requirement: int = 1,
                 effects: Dict[str, Any] = None, **kwargs):
        super().__init__(name, item_type=ItemType.WEAPON if slot == EquipmentSlot.WEAPON else ItemType.ARMOR, **kwargs)
        self.slot = slot
        self.level_requirement = level_requirement
        self.effects = effects or {}
        self.durability = 100
        self.max_durability = 100

    def can_equip(self, character) -> (bool, str):
        if character.level < self.level_requirement:
            return False, f"éœ€è¦ç­‰çº§ {self.level_requirement}"
        return True, "å¯ä»¥è£…å¤‡"

    def apply_effects(self, character):
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value + effect_value)

    def remove_effects(self, character):
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value - effect_value)

    def take_damage(self, amount: int):
        self.durability = max(0, self.durability - amount)
        if self.durability <= 0:
            print(f"âš ï¸ {self.name} å·²ç»æŸåï¼")

    def repair(self, amount: int = 100):
        self.durability = min(self.max_durability, self.durability + amount)
        print(f"ğŸ”§ {self.name} è¢«ä¿®å¤äº† {amount} ç‚¹è€ä¹…åº¦")

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nè£…å¤‡æ§½: {self.slot.value}"
        desc += f"\nç­‰çº§è¦æ±‚: {self.level_requirement}"
        desc += f"\nè€ä¹…åº¦: {self.durability}/{self.max_durability}"
        if self.effects:
            desc += f"\næ•ˆæœ: {', '.join([f'{k}+{v}' for k, v in self.effects.items()])}"
        return desc

class Weapon(Equipment):
    def __init__(self, name: str, damage_dice: str, damage_type: str = "ç‰©ç†",
                 weapon_type: str = "è¿‘æˆ˜", attack_bonus: int = 0, critical_range: int = 20,
                 critical_multiplier: int = 2, **kwargs):
        super().__init__(name, slot=EquipmentSlot.WEAPON, **kwargs)
        self.damage_dice = damage_dice
        self.damage_type = damage_type
        self.weapon_type = weapon_type
        self.attack_bonus = attack_bonus
        self.critical_range = critical_range
        self.critical_multiplier = critical_multiplier

    def get_damage(self, strength: int, crit: bool = False) -> int:
        dmg_res = roll_detail(self.damage_dice, crit=crit)
        damage = dmg_res["total"] + strength
        print(f"{self.name} ä¼¤å®³: {dmg_res['rolls']} + åŠ›é‡({strength}) â†’ {damage}")
        return damage

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä¼¤å®³: {self.damage_dice} + åŠ›é‡"
        desc += f"\nä¼¤å®³ç±»å‹: {self.damage_type}"
        desc += f"\næ­¦å™¨ç±»å‹: {self.weapon_type}"
        desc += f"\næ”»å‡»åŠ å€¼: {self.attack_bonus:+d}"
        desc += f"\næš´å‡»èŒƒå›´: {self.critical_range}"
        desc += f"\næš´å‡»å€æ•°: x{self.critical_multiplier}"
        return desc

class Armor(Equipment):
    def __init__(self, name: str, armor_class: int, armor_type: str = "è½»ç”²",
                 max_dex_bonus: Optional[int] = None, **kwargs):
        super().__init__(name, slot=EquipmentSlot.ARMOR, **kwargs)
        self.armor_class = armor_class
        self.armor_type = armor_type
        self.max_dex_bonus = max_dex_bonus

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næŠ¤ç”²ç­‰çº§: {self.armor_class}"
        desc += f"\næŠ¤ç”²ç±»å‹: {self.armor_type}"
        if self.max_dex_bonus is not None:
            desc += f"\næœ€å¤§æ•æ·åŠ å€¼: {self.max_dex_bonus}"
        return desc

class Consumable(BaseItem):
    def __init__(self, name: str, use_effect: Callable = None, charges: int = 1, **kwargs):
        super().__init__(name, item_type=ItemType.CONSUMABLE, stackable=True, **kwargs)
        self.use_effect = use_effect
        self.charges = charges

    def use(self, character) -> bool:
        if self.use_effect:
            return self.use_effect(character, self)
        return False

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä½¿ç”¨æ¬¡æ•°: {self.charges}"
        return desc

class HPPotion(Consumable):
    def __init__(self, name: str = "ç”Ÿå‘½è¯æ°´", heal_amount: int = 10, **kwargs):
        def heal_effect(character, item):
            character.heal(heal_amount)
            print(f"ğŸ’š {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {heal_amount} ç‚¹ç”Ÿå‘½ï¼ï¼ˆ{character.hp}/{character.max_hp} HPï¼‰")
            return True
        super().__init__(name, use_effect=heal_effect, **kwargs)
        self.heal_amount = heal_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.heal_amount} ç‚¹ç”Ÿå‘½å€¼"
        return desc

class MPPotion(Consumable):
    def __init__(self, name: str = "é­”æ³•è¯æ°´", mana_amount: int = 10, **kwargs):
        def mana_effect(character, item):
            character.mp = min(character.max_mp, character.mp + mana_amount)
            print(f"ğŸ”® {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {mana_amount} ç‚¹é­”æ³•ï¼ï¼ˆ{character.mp}/{character.max_mp} MPï¼‰")
            return True
        super().__init__(name, use_effect=mana_effect, **kwargs)
        self.mana_amount = mana_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.mana_amount} ç‚¹é­”æ³•å€¼"
        return desc

class ItemFactory:
    @staticmethod
    def create_weapon(name: str, damage_dice: str, **kwargs) -> Weapon:
        return Weapon(name, damage_dice, **kwargs)
    @staticmethod
    def create_armor(name: str, armor_class: int, **kwargs) -> Armor:
        return Armor(name, armor_class, **kwargs)
    @staticmethod
    def create_hp_potion(name: str = "ç”Ÿå‘½è¯æ°´", heal_amount: int = 10, **kwargs) -> HPPotion:
        return HPPotion(name, heal_amount, **kwargs)
    @staticmethod
    def create_mp_potion(name: str = "é­”æ³•è¯æ°´", mana_amount: int = 10, **kwargs) -> MPPotion:
        return MPPotion(name, mana_amount, **kwargs)
    @staticmethod
    def create_from_template(template: Dict) -> BaseItem:
        t = template.copy()
        if "rarity" in t and not isinstance(t["rarity"], ItemRarity):
            try:
                t["rarity"] = ItemRarity(t["rarity"])
            except Exception:
                t["rarity"] = ItemRarity.COMMON
        item_type_str = t.get("type") or t.get("item_type")
        if item_type_str and not isinstance(item_type_str, ItemType):
            try:
                t["item_type"] = ItemType(item_type_str)
            except Exception:
                t["item_type"] = ItemType.MATERIAL
        type_str = t.get("type")
        if type_str == "weapon":
            return Weapon(
                name=t["name"],
                damage_dice=t["damage_dice"],
                damage_type=t.get("damage_type", "ç‰©ç†"),
                weapon_type=t.get("weapon_type", "è¿‘æˆ˜"),
                attack_bonus=t.get("attack_bonus", 0),
                critical_range=t.get("critical_range", 20),
                critical_multiplier=t.get("critical_multiplier", 2),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "damage_dice", "damage_type", "weapon_type", "attack_bonus", "critical_range", "critical_multiplier"]}
            )
        elif type_str == "armor":
            return Armor(
                name=t["name"],
                armor_class=t["armor_class"],
                armor_type=t.get("armor_type", "è½»ç”²"),
                max_dex_bonus=t.get("max_dex_bonus"),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "armor_class", "armor_type", "max_dex_bonus"]}
            )
        elif type_str == "hp_potion":
            return HPPotion(
                name=t["name"],
                heal_amount=t.get("heal_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "heal_amount"]}
            )
        elif type_str == "mp_potion":
            return MPPotion(
                name=t["name"],
                mana_amount=t.get("mana_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "mana_amount"]}
            )
        t.pop("type", None)
        return BaseItem(**t)

def load_items_from_json(file_path: str) -> Dict[str, BaseItem]:
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        items = {}
        for item_name, template in data.items():
            items[item_name] = ItemFactory.create_from_template(template)
        return items
    except FileNotFoundError:
        print(f"ç‰©å“æ–‡ä»¶æœªæ‰¾åˆ°: {file_path}")
        return {}
    except json.JSONDecodeError as e:
        print(f"ç‰©å“æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
        return {}

def save_items_to_json(items: Dict[str, BaseItem], file_path: str):
    data = {}
    for item_name, item in items.items():
        data[item_name] = item.to_dict()
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# å…¨å±€ç‰©å“æ³¨å†Œè¡¨
ITEM_REGISTRY = {}
ITEM_JSON_PATH = "core/equipment/itemjson.json"

def load_global_items(json_path=ITEM_JSON_PATH):
    global ITEM_REGISTRY
    ITEM_REGISTRY = load_items_from_json(json_path)
    if not ITEM_REGISTRY:
        print(f"æœªèƒ½åŠ è½½ä»»ä½•ç‰©å“ï¼Œè¯·æ£€æŸ¥ {json_path}")
    else:
        print(f"å·²åŠ è½½ {len(ITEM_REGISTRY)} ä¸ªç‰©å“")

def get_item_by_name(item_name: str):
    if not ITEM_REGISTRY:
        load_global_items()
    item = ITEM_REGISTRY.get(item_name)
    if item:
        import copy
        return copy.deepcopy(item)
    else:
        raise ValueError(f"æœªæ‰¾åˆ°ç‰©å“: {item_name}")
from utils.dice import roll_detail
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import json
                 tags: List[str] = None):
        self.weight = weight
        self.stackable = stackable
        self.max_stack = max_stack
        self.tags = tags or []
        self.id = f"{name}_{rarity.value}_{item_type.value}"

    def __repr__(self):
        return f"<{self.rarity.value}{self.item_type.value}: {self.name}>"

    def get_display_name(self) -> str:
        """è·å–æ˜¾ç¤ºåç§°ï¼ˆåŒ…å«ç¨€æœ‰åº¦é¢œè‰²ï¼‰"""
        rarity_colors = {
            ItemRarity.COMMON: "",
            ItemRarity.UNCOMMON: "ğŸŸ¢",
            ItemRarity.RARE: "ğŸ”µ", 
            ItemRarity.EPIC: "ğŸŸ£",
            ItemRarity.LEGENDARY: "ğŸŸ¡"
        }
        return f"{rarity_colors.get(self.rarity, '')}{self.name}"

    def get_full_description(self) -> str:
        """è·å–å®Œæ•´æè¿°"""
        desc = f"{self.get_display_name()}\n"
        desc += f"ç±»å‹: {self.item_type.value}\n"
        desc += f"ç¨€æœ‰åº¦: {self.rarity.value}\n"
        desc += f"ä»·å€¼: {self.value} é‡‘å¸\n"
        if self.weight > 0:
            desc += f"é‡é‡: {self.weight} ç£…\n"
        if self.description:
            desc += f"æè¿°: {self.description}\n"
        if self.tags:
            desc += f"æ ‡ç­¾: {', '.join(self.tags)}\n"
        return desc.strip()

    def can_use(self, character) -> bool:
        """æ£€æŸ¥è§’è‰²æ˜¯å¦å¯ä»¥ä½¿ç”¨æ­¤ç‰©å“"""
        return True

    def use(self, character) -> bool:
        """ä½¿ç”¨ç‰©å“ï¼ˆåŸºç±»é»˜è®¤å®ç°ï¼‰"""
        return False

    def to_dict(self) -> Dict:
        """è½¬æ¢ä¸ºå­—å…¸ï¼ˆç”¨äºä¿å­˜ï¼‰"""
        return {
            "name": self.name,
            "description": self.description,
            "value": self.value,
            "rarity": self.rarity.value,
            "item_type": self.item_type.value,
            "weight": self.weight,
            "stackable": self.stackable,
            "max_stack": self.max_stack,
            "tags": self.tags
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'BaseItem':
        """ä»å­—å…¸åˆ›å»ºç‰©å“"""
        return cls(
            name=data["name"],
            description=data.get("description", ""),
            value=data.get("value", 0),
            rarity=ItemRarity(data.get("rarity", "æ™®é€š")),
            item_type=ItemType(data.get("item_type", "ææ–™")),
            weight=data.get("weight", 0.0),
            stackable=data.get("stackable", False),
            max_stack=data.get("max_stack", 1),
            tags=data.get("tags", [])
        )


class Equipment(BaseItem):
    """è£…å¤‡åŸºç±»"""
    def __init__(self, 
                 name: str,
                 slot: EquipmentSlot,
                 level_requirement: int = 1,
                 effects: Dict[str, Any] = None,
                 **kwargs):
        super().__init__(name, item_type=ItemType.WEAPON if slot == EquipmentSlot.WEAPON else ItemType.ARMOR, **kwargs)
        self.slot = slot
        self.level_requirement = level_requirement
        self.effects = effects or {}
        self.durability = 100
        self.max_durability = 100

    def can_equip(self, character) -> bool:
        """æ£€æŸ¥è§’è‰²æ˜¯å¦å¯ä»¥è£…å¤‡"""
        if character.level < self.level_requirement:
            return False, f"éœ€è¦ç­‰çº§ {self.level_requirement}"
        return True, "å¯ä»¥è£…å¤‡"

    def apply_effects(self, character):
        """åº”ç”¨è£…å¤‡æ•ˆæœåˆ°è§’è‰²"""
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value + effect_value)

    def remove_effects(self, character):
        """ç§»é™¤è£…å¤‡æ•ˆæœ"""
        for effect_name, effect_value in self.effects.items():
            if hasattr(character, effect_name):
                current_value = getattr(character, effect_name)
                setattr(character, effect_name, current_value - effect_value)

    def take_damage(self, amount: int):
        """è£…å¤‡å—åˆ°ä¼¤å®³ï¼ˆé™ä½è€ä¹…åº¦ï¼‰"""
        self.durability = max(0, self.durability - amount)
        if self.durability <= 0:
            print(f"âš ï¸ {self.name} å·²ç»æŸåï¼")

    def repair(self, amount: int = 100):
        """ä¿®å¤è£…å¤‡"""
        self.durability = min(self.max_durability, self.durability + amount)
        print(f"ğŸ”§ {self.name} è¢«ä¿®å¤äº† {amount} ç‚¹è€ä¹…åº¦")

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nè£…å¤‡æ§½: {self.slot.value}"
        desc += f"\nç­‰çº§è¦æ±‚: {self.level_requirement}"
        desc += f"\nè€ä¹…åº¦: {self.durability}/{self.max_durability}"
        if self.effects:
            desc += f"\næ•ˆæœ: {', '.join([f'{k}+{v}' for k, v in self.effects.items()])}"
        return desc


class Weapon(Equipment):
    """æ­¦å™¨ç±»"""
    def __init__(self, 
                 name: str,
                 damage_dice: str,
                 damage_type: str = "ç‰©ç†",
                 weapon_type: str = "è¿‘æˆ˜",
                 attack_bonus: int = 0,
                 critical_range: int = 20,
                 critical_multiplier: int = 2,
                 **kwargs):
        super().__init__(name, slot=EquipmentSlot.WEAPON, **kwargs)
        self.damage_dice = damage_dice
        self.damage_type = damage_type
        self.weapon_type = weapon_type
        self.attack_bonus = attack_bonus
        self.critical_range = critical_range
        self.critical_multiplier = critical_multiplier

    def get_damage(self, strength: int, crit: bool = False) -> int:
        """è®¡ç®—ä¼¤å®³"""
        dmg_res = roll_detail(self.damage_dice, crit=crit)
        damage = dmg_res["total"] + strength
        print(f"{self.name} ä¼¤å®³: {dmg_res['rolls']} + åŠ›é‡({strength}) â†’ {damage}")
        return damage

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä¼¤å®³: {self.damage_dice} + åŠ›é‡"
        desc += f"\nä¼¤å®³ç±»å‹: {self.damage_type}"
        desc += f"\næ­¦å™¨ç±»å‹: {self.weapon_type}"
        desc += f"\næ”»å‡»åŠ å€¼: {self.attack_bonus:+d}"
        desc += f"\næš´å‡»èŒƒå›´: {self.critical_range}"
        desc += f"\næš´å‡»å€æ•°: x{self.critical_multiplier}"
        return desc


class Armor(Equipment):
    """æŠ¤ç”²ç±»"""
    def __init__(self, 
                 name: str,
                 armor_class: int,
                 armor_type: str = "è½»ç”²",
                 max_dex_bonus: Optional[int] = None,
                 **kwargs):
        super().__init__(name, slot=EquipmentSlot.ARMOR, **kwargs)
        self.armor_class = armor_class
        self.armor_type = armor_type
        self.max_dex_bonus = max_dex_bonus

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næŠ¤ç”²ç­‰çº§: {self.armor_class}"
        desc += f"\næŠ¤ç”²ç±»å‹: {self.armor_type}"
        if self.max_dex_bonus is not None:
            desc += f"\næœ€å¤§æ•æ·åŠ å€¼: {self.max_dex_bonus}"
        return desc


class Consumable(BaseItem):
    """æ¶ˆè€—å“ç±»"""
    def __init__(self, 
                 name: str,
                 use_effect: Callable = None,
                 charges: int = 1,
                 **kwargs):
        super().__init__(name, item_type=ItemType.CONSUMABLE, stackable=True, **kwargs)
        self.use_effect = use_effect
        self.charges = charges

    def use(self, character) -> bool:
        """ä½¿ç”¨æ¶ˆè€—å“"""
        if self.use_effect:
            return self.use_effect(character, self)
        return False

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\nä½¿ç”¨æ¬¡æ•°: {self.charges}"
        return desc


class HPPotion(Consumable):
    """ç”Ÿå‘½è¯æ°´"""
    def __init__(self, 
                 name: str = "ç”Ÿå‘½è¯æ°´",
                 heal_amount: int = 10,
                 **kwargs):
        def heal_effect(character, item):
            character.heal(heal_amount)
            print(f"ğŸ’š {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {heal_amount} ç‚¹ç”Ÿå‘½ï¼ï¼ˆ{character.hp}/{character.max_hp} HPï¼‰")
            return True
        
        super().__init__(name, use_effect=heal_effect, **kwargs)
        self.heal_amount = heal_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.heal_amount} ç‚¹ç”Ÿå‘½å€¼"
        return desc


class MPPotion(Consumable):
    """é­”æ³•è¯æ°´"""
    def __init__(self, 
                 name: str = "é­”æ³•è¯æ°´",
                 mana_amount: int = 10,
                 **kwargs):
        def mana_effect(character, item):
            character.mp = min(character.max_mp, character.mp + mana_amount)
            print(f"ğŸ”® {character.name} ä½¿ç”¨äº† {item.name}ï¼Œæ¢å¤äº† {mana_amount} ç‚¹é­”æ³•ï¼ï¼ˆ{character.mp}/{character.max_mp} MPï¼‰")
            return True
        
        super().__init__(name, use_effect=mana_effect, **kwargs)
        self.mana_amount = mana_amount

    def get_full_description(self) -> str:
        desc = super().get_full_description()
        desc += f"\næ²»ç–—æ•ˆæœ: æ¢å¤ {self.mana_amount} ç‚¹é­”æ³•å€¼"
        return desc


class ItemFactory:
    """ç‰©å“å·¥å‚ç±»"""
    
    @staticmethod
    def create_weapon(name: str, damage_dice: str, **kwargs) -> Weapon:
        """åˆ›å»ºæ­¦å™¨"""
        return Weapon(name, damage_dice, **kwargs)
    
    @staticmethod
    def create_armor(name: str, armor_class: int, **kwargs) -> Armor:
        """åˆ›å»ºæŠ¤ç”²"""
        return Armor(name, armor_class, **kwargs)
    
    @staticmethod
    def create_hp_potion(name: str = "ç”Ÿå‘½è¯æ°´", heal_amount: int = 10, **kwargs) -> HPPotion:
        """åˆ›å»ºç”Ÿå‘½è¯æ°´"""
        return HPPotion(name, heal_amount, **kwargs)
    
    @staticmethod
    def create_mp_potion(name: str = "é­”æ³•è¯æ°´", mana_amount: int = 10, **kwargs) -> MPPotion:
        """åˆ›å»ºé­”æ³•è¯æ°´"""
        return MPPotion(name, mana_amount, **kwargs)

    @staticmethod
    def create_from_template(template: Dict) -> BaseItem:
        """ä»æ¨¡æ¿åˆ›å»ºç‰©å“ï¼Œè‡ªåŠ¨å°†å­—ç¬¦ä¸²å­—æ®µè½¬æ¢ä¸ºæšä¸¾ç±»å‹"""
        # å¤„ç†ç¨€æœ‰åº¦å’Œç±»å‹
        t = template.copy()
        # å¤„ç† rarity
        if "rarity" in t and not isinstance(t["rarity"], ItemRarity):
            try:
                t["rarity"] = ItemRarity(t["rarity"])
            except Exception:
                t["rarity"] = ItemRarity.COMMON
        # å¤„ç† type/item_type
        item_type_str = t.get("type") or t.get("item_type")
        if item_type_str and not isinstance(item_type_str, ItemType):
            try:
                t["item_type"] = ItemType(item_type_str)
            except Exception:
                t["item_type"] = ItemType.MATERIAL

        # å…¨å±€ç‰©å“æ³¨å†Œè¡¨
        ITEM_REGISTRY = {}

        # é»˜è®¤ç‰©å“jsonè·¯å¾„
        ITEM_JSON_PATH = "core/equipment/itemjson.json"

        def load_global_items(json_path=ITEM_JSON_PATH):
            """åŠ è½½å…¨å±€ç‰©å“æ³¨å†Œè¡¨"""
            global ITEM_REGISTRY
            ITEM_REGISTRY = load_items_from_json(json_path)
            if not ITEM_REGISTRY:
                print(f"æœªèƒ½åŠ è½½ä»»ä½•ç‰©å“ï¼Œè¯·æ£€æŸ¥ {json_path}")
            else:
                print(f"å·²åŠ è½½ {len(ITEM_REGISTRY)} ä¸ªç‰©å“")

        def get_item_by_name(item_name: str):
            """ä»å…¨å±€æ³¨å†Œè¡¨è·å–ç‰©å“å‰¯æœ¬"""
            if not ITEM_REGISTRY:
                load_global_items()
            item = ITEM_REGISTRY.get(item_name)
            if item:
                import copy
                return copy.deepcopy(item)
            else:
                raise ValueError(f"æœªæ‰¾åˆ°ç‰©å“: {item_name}")
        elif type_str == "armor":
            return Armor(
                name=t["name"],
                armor_class=t["armor_class"],
                armor_type=t.get("armor_type", "è½»ç”²"),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "armor_class", "armor_type"]}
            )
        elif type_str == "hp_potion":
            return HPPotion(
                name=t["name"],
                heal_amount=t.get("heal_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "heal_amount"]}
            )
        elif type_str == "mp_potion":
            return MPPotion(
                name=t["name"],
                mana_amount=t.get("mana_amount", 10),
                **{k: v for k, v in t.items() if k not in ["type", "item_type", "name", "mana_amount"]}
            )
        # å…¶å®ƒç±»å‹
        t.pop("type", None)
        return BaseItem(**t)


# é¢„è®¾ç‰©å“æ¨¡æ¿
PRESET_ITEMS = {
    # æ­¦å™¨
    "é“å‰‘": {
        "type": "weapon",
        "name": "é“å‰‘",
        "description": "ä¸€æŠŠæ™®é€šçš„é“åˆ¶é•¿å‰‘",
        "damage_dice": "1d8",
        "damage_type": "ç‰©ç†",
        "weapon_type": "è¿‘æˆ˜",
        "attack_bonus": 0,
        "value": 15,
        "rarity": "æ™®é€š",
        "level_requirement": 1,
        "effects": {"strength": 1}
    },
    
    "é­”æ³•æ³•æ–": {
        "type": "weapon", 
        "name": "é­”æ³•æ³•æ–",
        "description": "é•¶åµŒç€é­”æ³•æ°´æ™¶çš„æ³•æ–",
        "damage_dice": "1d6",
        "damage_type": "é­”æ³•",
        "weapon_type": "è¿œç¨‹",
        "attack_bonus": 2,
        "value": 50,
        "rarity": "ä¼˜ç§€",
        "level_requirement": 3,
        "effects": {"intelligence": 2}
    },
    
    # æŠ¤ç”²
    "çš®ç”²": {
        "type": "armor",
        "name": "çš®ç”²", 
        "description": "ç”¨çš®é©åˆ¶æˆçš„è½»ä¾¿æŠ¤ç”²",
        "armor_class": 2,
        "armor_type": "è½»ç”²",
        "value": 10,
        "rarity": "æ™®é€š",
        "level_requirement": 1,
        "effects": {"agility": 1}
    },
    
    "é“ç”²": {
        "type": "armor",
        "name": "é“ç”²",
        "description": "åšé‡çš„é“åˆ¶æŠ¤ç”²",
        "armor_class": 5,
        "armor_type": "é‡ç”²", 
        "max_dex_bonus": 2,
        "value": 30,
        "rarity": "æ™®é€š",
        "level_requirement": 2,
        "effects": {"strength": 1}
    },
    
    # è¯æ°´
    "å°ç”Ÿå‘½è¯æ°´": {
        "type": "hp_potion",
        "name": "å°ç”Ÿå‘½è¯æ°´",
        "description": "æ¢å¤å°‘é‡ç”Ÿå‘½å€¼çš„çº¢è‰²è¯æ°´",
        "heal_amount": 10,
        "value": 5,
        "rarity": "æ™®é€š"
    },
    
    "å¤§ç”Ÿå‘½è¯æ°´": {
        "type": "hp_potion", 
        "name": "å¤§ç”Ÿå‘½è¯æ°´",
        "description": "æ¢å¤å¤§é‡ç”Ÿå‘½å€¼çš„çº¢è‰²è¯æ°´",
        "heal_amount": 25,
        "value": 15,
        "rarity": "ä¼˜ç§€"
    },
    
    "å°é­”æ³•è¯æ°´": {
        "type": "mp_potion",
        "name": "å°é­”æ³•è¯æ°´", 
        "description": "æ¢å¤å°‘é‡é­”æ³•å€¼çš„è“è‰²è¯æ°´",
        "mana_amount": 10,
        "value": 8,
        "rarity": "æ™®é€š"
    }
}


def create_preset_item(item_name: str) -> BaseItem:
    """åˆ›å»ºé¢„è®¾ç‰©å“"""
    if item_name in PRESET_ITEMS:
        return ItemFactory.create_from_template(PRESET_ITEMS[item_name])
    else:
        raise ValueError(f"æœªçŸ¥çš„é¢„è®¾ç‰©å“: {item_name}")


def load_items_from_json(file_path: str) -> Dict[str, BaseItem]:
    """ä»JSONæ–‡ä»¶åŠ è½½ç‰©å“"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        items = {}
        for item_name, template in data.items():
            items[item_name] = ItemFactory.create_from_template(template)
        
        return items
    except FileNotFoundError:
        print(f"ç‰©å“æ–‡ä»¶æœªæ‰¾åˆ°: {file_path}")
        return {}
    except json.JSONDecodeError as e:
        print(f"ç‰©å“æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}")
        return {}


def save_items_to_json(items: Dict[str, BaseItem], file_path: str):
    """ä¿å­˜ç‰©å“åˆ°JSONæ–‡ä»¶"""
    data = {}
    for item_name, item in items.items():
        data[item_name] = item.to_dict()
    
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)